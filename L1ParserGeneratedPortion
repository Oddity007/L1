/*

Program
	First:
		Universe
		Self
		Natural
		Dollar
		Identifier
		OpenBracket
		Let
		String
		OpenParenthesis
	Follow:
		Done
Exp
	First:
		Universe
		Self
		Natural
		Let
		Identifier
		OpenBracket
		Dollar
		String
		OpenParenthesis
	Follow:
		CloseParenthesis
		Done
ExpFollow
	First:
		SingleColon
		
		SingleEqual
	Follow:
		CloseParenthesis
		Done
ChainedClosedExp
	First:
		Natural
		String
		Identifier
		Universe
		OpenBracket
		Dollar
		OpenParenthesis
		Self
	Follow:
		Terminal
		CloseParenthesis
		Done
ChainedClosedExpFollow
	First:
		Universe
		OpenParenthesis
		OpenBracket
		Self
		Natural
		DoubleBarArrow
		Ampersand
		Identifier
		
		Dollar
		SingleBarArrow
		String
	Follow:
		Terminal
		CloseParenthesis
		Done
ChainedClosedExpAmpersandFollow
	First:
		Ampersand
	Follow:
		Terminal
		CloseParenthesis
		Done
DoChainedClosedExpFollowCallAction
	First:
		
	Follow:
		Done
		String
		CloseParenthesis
		Self
		Identifier
		Natural
		Ampersand
		Universe
		OpenBracket
		Dollar
		Terminal
		OpenParenthesis
ChainedClosedExpCallFollow
	First:
		Universe
		Self
		Identifier
		
		Ampersand
		OpenParenthesis
		OpenBracket
		Dollar
		Natural
		String
	Follow:
		Terminal
		CloseParenthesis
		Done
ClosedExpList
	First:
		Universe
		Self
		Natural
		
		Identifier
		OpenBracket
		Dollar
		String
		OpenParenthesis
	Follow:
		SingleEqual
		CloseBracket
		Comma
ConsDefList
	First:
		Identifier
		
	Follow:
		CloseBracket
ConsDefListFollow
	First:
		
		Comma
	Follow:
		CloseBracket
ClosedExp
	First:
		Identifier
		OpenParenthesis
		Natural
		Universe
		OpenBracket
		String
		Dollar
		Self
	Follow:
		CloseBracket
		SingleEqual
		Universe
		SingleColon
		DoubleBarArrow
		OpenBracket
		CloseParenthesis
		Comma
		OpenParenthesis
		Self
		Natural
		Terminal
		Ampersand
		Done
		String
		Dollar
		SingleBarArrow
		Identifier
*/

static const unsigned char NonterminalOffset = 24;
static const unsigned char RuleTerminationID = 23;
static const unsigned char ProgramNonterminalID = 24;
static const unsigned char ActionOffset = 53;
static const unsigned char RuleTable[29][9]=
{
	{26,53, 23},
	{52,29,23},
	{18,2,40,6,30,3,26,54, 23},
	{6,30,3,26,55, 23},
	{7,30,56, 23},
	{23},
	{52,35,23},
	{9,30,57, 23},
	{10,30,58, 23},
	{13,30,59, 23},
	{60, 23},
	{38,23},
	{52,34,38,23},
	{33,23},
	{23},
	{52,40,61, 23},
	{64, 23},
	{2,40,44,63, 23},
	{64, 23},
	{15,42,23},
	{23},
	{11,52,65, 23},
	{2,66, 23},
	{1,67, 23},
	{0,68, 23},
	{19,69, 23},
	{20,0,70, 23},
	{16,42,17,71, 23},
	{4,26,5,23},
};
static const unsigned char ParseTable[29][23]=
{
	{1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,},
	{2,2,2,0,2,0,0,0,0,0,0,2,0,0,0,0,2,0,3,2,2,0,0,},
	{2,2,2,0,2,0,0,0,0,0,0,2,0,0,0,0,2,0,3,2,2,0,0,},
	{0,0,0,0,0,6,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,},
	{0,0,0,0,0,6,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,},
	{0,0,0,0,0,6,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,},
	{7,7,7,0,7,0,0,0,0,0,0,7,0,0,0,0,7,0,0,7,7,0,0,},
	{12,12,12,12,12,12,0,0,0,8,9,12,0,12,0,0,12,0,0,12,12,12,0,},
	{12,12,12,12,12,12,0,0,0,8,9,12,0,12,0,0,12,0,0,12,12,12,0,},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,},
	{11,11,11,11,11,11,0,0,0,0,0,11,0,11,0,0,11,0,0,11,11,11,0,},
	{12,12,12,12,12,12,0,0,0,8,9,12,0,12,0,0,12,0,0,12,12,12,0,},
	{13,13,13,15,13,15,0,0,0,0,0,13,0,14,0,0,13,0,0,13,13,15,0,},
	{13,13,13,15,13,15,0,0,0,0,0,13,0,14,0,0,13,0,0,13,13,15,0,},
	{13,13,13,15,13,15,0,0,0,0,0,13,0,14,0,0,13,0,0,13,13,15,0,},
	{16,16,16,0,16,0,17,0,0,0,0,16,0,0,0,17,16,17,0,16,16,0,0,},
	{16,16,16,0,16,0,17,0,0,0,0,16,0,0,0,17,16,17,0,16,16,0,0,},
	{0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,},
	{0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,21,0,0,0,0,0,},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,21,0,0,0,0,0,},
	{25,24,23,0,29,0,0,0,0,0,0,22,0,0,0,0,28,0,0,26,27,0,0,},
	{25,24,23,0,29,0,0,0,0,0,0,22,0,0,0,0,28,0,0,26,27,0,0,},
	{25,24,23,0,29,0,0,0,0,0,0,22,0,0,0,0,28,0,0,26,27,0,0,},
	{25,24,23,0,29,0,0,0,0,0,0,22,0,0,0,0,28,0,0,26,27,0,0,},
	{25,24,23,0,29,0,0,0,0,0,0,22,0,0,0,0,28,0,0,26,27,0,0,},
	{25,24,23,0,29,0,0,0,0,0,0,22,0,0,0,0,28,0,0,26,27,0,0,},
	{25,24,23,0,29,0,0,0,0,0,0,22,0,0,0,0,28,0,0,26,27,0,0,},
	{25,24,23,0,29,0,0,0,0,0,0,22,0,0,0,0,28,0,0,26,27,0,0,},
};
static const char* SymbolName(unsigned char c)
{
	switch(c)
	{
		case 24: return "Program";
		case 26: return "Exp";
		case 29: return "ExpFollow";
		case 30: return "ChainedClosedExp";
		case 35: return "ChainedClosedExpFollow";
		case 33: return "ChainedClosedExpAmpersandFollow";
		case 34: return "DoChainedClosedExpFollowCallAction";
		case 38: return "ChainedClosedExpCallFollow";
		case 40: return "ClosedExpList";
		case 42: return "ConsDefList";
		case 44: return "ConsDefListFollow";
		case 52: return "ClosedExp";
		case 0: return "Natural";
		case 1: return "String";
		case 2: return "Identifier";
		case 3: return "Terminal";
		case 4: return "OpenParenthesis";
		case 5: return "CloseParenthesis";
		case 6: return "SingleEqual";
		case 7: return "SingleColon";
		case 8: return "DoubleColon";
		case 9: return "SingleBarArrow";
		case 10: return "DoubleBarArrow";
		case 11: return "Dollar";
		case 12: return "Percent";
		case 13: return "Ampersand";
		case 14: return "Declare";
		case 15: return "Comma";
		case 16: return "OpenBracket";
		case 17: return "CloseBracket";
		case 18: return "Let";
		case 19: return "Self";
		case 20: return "Universe";
		case 21: return "Done";
		case 22: return "";
		default: return NULL;
	}
}
static void HandleAction(L1Parser* self, unsigned char action, const char* tokenString, size_t tokenStringLength)
{
	switch(action)
	{
		case 55: {size_t followingContext = PopNodeLocation(self); size_t source = PopNodeLocation(self); size_t destination = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeAssign); node.data.assign.destination = destination; node.data.assign.source = source; node.data.assign.followingContext = followingContext; PushNode(self, & node);}; break;
		case 67: {L1ParserASTNode node; node.type = L1ParserASTNodeTypeString; node.data.string.tokenIndex = self->currentTokenIndex; PushNode(self, & node);}; break;
		case 66: {L1ParserASTNode node; node.type = L1ParserASTNodeTypeIdentifier; node.data.identifier.tokenIndex = self->currentTokenIndex; PushNode(self, & node);}; break;
		case 57: {size_t result = PopNodeLocation(self); size_t argument = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeLambda); node.data.lambda.argument = argument; node.data.lambda.result = result; PushNode(self, & node);}; break;
		case 68: {L1ParserASTNode node; node.type = L1ParserASTNodeTypeNatural; node.data.natural.tokenIndex = self->currentTokenIndex; PushNode(self, & node);}; break;
		case 56: {size_t type = PopNodeLocation(self); size_t value = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeAnnotate); node.data.annotate.value = value; node.data.annotate.type = type; PushNode(self, & node);}; break;
		case 59: {size_t second = PopNodeLocation(self); size_t first = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeOverload); node.data.overload.first = first; node.data.overload.second = second; PushNode(self, & node);}; break;
		case 69: {L1ParserASTNode node; node.type = L1ParserASTNodeTypeSelf; PushNode(self, & node);}; break;
		case 65: {size_t expression = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeEvaluateArgument); node.data.evaluateArgument.expression = expression; PushNode(self, & node);}; break;
		case 60: {size_t argument = PopNodeLocation(self); size_t callee = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeCall); node.data.call.callee = callee; node.data.call.argument = argument; PushNode(self, & node);}; break;
		case 63: {size_t previousConstructorList = PopNodeLocation(self); size_t argumentList = PopNodeLocation(self); size_t constructorName = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeConstructorList); node.data.constructorList.argumentList = argumentList; node.data.constructorList.constructorName = constructorName; node.data.constructorList.previousConstructorList = previousConstructorList; PushNode(self, & node);}; break;
		case 53: {self->rootASTNode = PopNodeLocation(self);}; break;
		case 64: {PushNode(self, NULL);}; break;
		case 71: {size_t constructorList = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeADT); node.data.adt.constructorList = constructorList; PushNode(self, & node);}; break;
		case 70: {L1ParserASTNode node; node.type = L1ParserASTNodeTypeNatural; node.data.natural.tokenIndex = self->currentTokenIndex; PushNode(self, & node); node.type = L1ParserASTNodeTypeUniverse; node.data.universe.level = PopNodeLocation(self); PushNode(self, & node);}; break;
		case 58: {size_t result = PopNodeLocation(self); size_t argument = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypePi); node.data.pi.argument = argument; node.data.pi.result = result; PushNode(self, & node);}; break;
		case 54: {size_t followingContext = PopNodeLocation(self); size_t source = PopNodeLocation(self); size_t argumentList = PopNodeLocation(self); size_t destination = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeLet); node.data.let.destination = destination; node.data.let.argumentList = argumentList; node.data.let.source = source; node.data.let.followingContext = followingContext; PushNode(self, & node);}; break;
		case 61: {size_t previousArgumentList = PopNodeLocation(self); size_t argument = PopNodeLocation(self); L1ParserASTNode node; node.type = (L1ParserASTNodeTypeArgumentList); node.data.argumentList.argument = argument; node.data.argumentList.previousArgumentList = previousArgumentList; PushNode(self, & node);}; break;
		default: break;
	}
}

